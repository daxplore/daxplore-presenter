/*
 *  Copyright 2012 Axel Winkler, Daniel Dun√©r
 * 
 *  This file is part of Daxplore Presenter.
 *
 *  Daxplore Presenter is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  Daxplore Presenter is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Daxplore Presenter.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.daxplore.presenter.shared;

import java.util.ArrayList;
import java.util.List;


/**
 * The Embed Definition specifies how an embedded chart should be displayed.
 * 
 * <p>The definition currently contains these flags:
 * <ul>
 * <li>NULL, a way to set "no flag"</li>
 * <li>LEGEND, set to true if the chart legend should be displayed</li>
 * <li>TRANSPARENT, set to true if the chart's background should be transparent
 * which allows it to fit better into some sites. Otherwise the background is
 * white.</li>
 * <li>PRINT, set to true to use a printer-friendly mode that uses images
 * instead of background-colors and removes interactivity</li>
 * </ul>
 * 
 * <p><b>Note:</b> This is not the same thing as the
 * {@link QueryDefinition}, which specifies what chart type should be displayed
 * and what content it should hold.</p>
 */
public class EmbedDefinition {
	
	/**
	 * An enum that defines the supported flags.
	 * 
	 * <p>Each flag is created with a number in the 2^n series. This makes it
	 * possible to represent the flags as a series of bits by or-ing the flags
	 * together.</p>
	 * 
	 * <p>The enum defines the flags:
	 * <ul>
	 * <li><b>NULL</b>, a way to set "no flag"</li>
	 * <li><b>LEGEND</b>, set to true if the chart legend should be displayed</li>
	 * <li><b>TRANSPARENT</b>, set to true if the chart's background should be transparent
	 * which allows it to fit better into some sites. Otherwise the background is
	 * white</li>
	 * <li><b>PRINT</b>, set to true to use a printer-friendly mode that uses images
	 * instead of background-colors and removes interactivity</li>
 * </ul>
	 */
	public enum EmbedFlag {
		
		/** A way to set "no flag". */
		NULL(0), 
		
		/** Set to true if the chart legend should be displayed. */
		LEGEND(1), 
		
		/**
		 * Set to true if the chart's background should be transparent which
		 * allows it to fit better into some sites. Otherwise the background is
		 * white.
		 */
		TRANSPARENT(2), 
		
		/**
		 * Set to true to use a printer-friendly mode that uses images instead
		 * of background-colors and removes interactivity.
		 */
		PRINT(4);

		/**
		 * The value of the bit-position used when encoding this flag in a long.
		 */
		protected final long bitValue;
		
		/**
		 * Instantiates a new embed flag.
		 * 
		 * @param bitValue
		 *            the value of the bit-position used when encoding this flag in a long
		 */
		EmbedFlag(int bitValue) {
			this.bitValue = bitValue;
		}
		
		/**
		 * Get an array of flags from a long containing a flag-bit-pattern
		 * generated by {@link #encodeFlags(EmbedFlag[])}.
		 * 
		 * @param flaglong
		 * 				a long defining the flags
		 * @return an array of the defined flags
		 */
		protected static EmbedFlag[] decodeFlags(long flaglong){
			if(flaglong == 0) return new EmbedFlag[0];
			ArrayList<EmbedFlag> flags = new ArrayList<EmbedFlag>();
			for(EmbedFlag f: EmbedFlag.values()){
				if((flaglong & f.bitValue) != 0) flags.add(f);
			}
			return flags.toArray(new EmbedFlag[0]);
		}
		
		/**
		 * Encode an array of flags as a long, using a flag-bit-pattern,
		 * that can be decoded by {@link #decodeFlags(long)}.
		 * 
		 * @param flags
		 *            the flags
		 * @return a long representing the flags
		 */
		protected static long encodeFlags(EmbedFlag[] flags) {
			long flaglong = 0;
			for(EmbedFlag f : flags){
				flaglong = flaglong | f.bitValue;
			}
			return flaglong;
		}
	}
	
	protected EmbedFlag[] flags;
	
	/**
	 * Instantiates a new embed definition from a base64-encoded string
	 * representation of an embed definition.
	 * 
	 * @param embedDefinitionString
	 *            a string representation of an embed definition
	 * @throws IllegalArgumentException
	 *             thrown if the definition is invalid
	 */
	public EmbedDefinition(String embedDefinitionString) throws IllegalArgumentException {
		if(embedDefinitionString == null || embedDefinitionString == "") {
			throw new IllegalArgumentException("No string to restore from");
		}
		flags = new EmbedFlag[0];
		try {
			long flagLong = Base64.decodeLong(embedDefinitionString);
			flags = EmbedFlag.decodeFlags(flagLong);
		} catch (NumberFormatException e) {
			throw new IllegalArgumentException(e);
		}
	}
	
	/**
	 * Instantiates a new embed definition from a list of flags.
	 * 
	 * @param flags
	 *            the flags that should be set
	 */
	public EmbedDefinition(List<EmbedFlag> flags){
		this.flags = flags.toArray(new EmbedFlag[0]);
	}
	
	/**
	 * Instantiates a new embed definition from a bit-based representation
	 * of the flags.
	 * 
	 * @param flags
	 *            the flags as a series of bits
	 */
	public EmbedDefinition(long flags){
		this.flags = EmbedFlag.decodeFlags(flags);
	}
	
	/**
	 * Get the String representation of the embed definition.
	 * 
	 * @return the definition as a string
	 */
	public String getAsString(){
		return Base64.encodeLong(EmbedFlag.encodeFlags(flags));
	}
	
	/**
	 * Check if a specific flag is set in this embed definition.
	 * 
	 * @param flag
	 *            the flag to check for
	 * @return true, if the flag is set
	 */
	public boolean hasFlag(EmbedFlag flag){
		for(EmbedFlag f: flags){
			if(f.equals(flag)) return true;
		}
		return false;
	}
}
